<head>
	<title>Ardi: Welcome to the Weightless Web</title>
	<meta
		name="description"
		content="Ardi is a tiny (but fierce) web component framework."
	/>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<meta charset="UTF-8" />
	<link rel="stylesheet" href="/css/styles.css" />
</head>

<body>
	<nav>
		<a href="/">Ardi</a>
		<div>
			<a href="/docs.html" class="active">Docs</a>
			<a href="/playground.html">Playground</a>
		</div>
	</nav>

	<main class="docs">
		<div class="docs-container">
			<h1>Docs</h1>

			<aside>
				<div class="toc">
					<h2>Contents</h2>
					<ul>
						<li><a href="#installation">Installation</a></li>
						<br />
						<li>
							<a href="#use">Usage</a>
							<ul>
								<li><a href="#component">component</a></li>
								<li><a href="#props">props</a></li>
								<li><a href="#state">state</a></li>
								<li>
									<a href="#template">template()</a>
									<ul>
										<li><a href="#slots">slots</a></li>
										<li><a href="#parts">parts</a></li>
										<li><a href="#refs">refs</a></li>
										<li><a href="#events">@events</a></li>
									</ul>
								</li>
								<li><a href="#ready">ready()</a></li>
								<li><a href="#intersect">intersect(ratio)</a></li>
							</ul>
						</li>
						<br />
						<li>
							<a href="#advanced">Advanced</a>
							<ul>
								<li><a href="#render">render()</a></li>
							</ul>
						</li>
						<br />
						<li>
							<a href="#frameworks">Ardi + Other Frameworks</a>
						</li>
					</ul>
				</div>
			</aside>

			<p>
				Ardi is a highly-optimized, kid-friendly web component framework. Ardi
				is only 3kb and you can install it from NPM or a CDN. You can use Ardi
				to build full-scale applications or just to add a little sprinkle of
				reactivity to your site. Ardi components are universal and have been
				tested with React/Next/Gatsby, Vue/Nuxt, Svelte, Astro, Remix, 11ty,
				Wordpress, and fully-static sites.
			</p>

			<br />

			<h2 id="installation">Installation</h2>

			<h3>Option 1: NPM</h3>

			<pre class="language-shell">
				<p class="code-label">shell</p>
				<code class="language-shell">
npm i ardi
				</code>
			</pre>

			<pre>
				<p class="code-label">javascript</p>
				<code data-lang="text/javascript">
import ardi, {html} from 'ardi';

ardi({ component: 'my-component', })
				</code>
			</pre>

			<h3 style="margin-top: 1.5em">Option 2: CDN</h3>

			<pre>
				<p class="code-label">html</p>
				<code data-lang="text/html">
&lt;script type=module&gt;
	import ardi, {html} from '//unpkg.com';

	ardi({ component: 'my-component', })
&lt;/script&gt;
				</code>
			</pre>

			<br /><br /><br />

			<h2 id="use">Usage</h2>

			<p>
				Ardi components are composed as objects, using the keys outlined below
				and any of your own. The example code is from the
				<code>&lt;gauge-demo&gt;</code> component. You can review the full code
				<a href="/playground.html?component=gauge"> in the playground</a>.
			</p>

			<hr />

			<h3 id="component">component</h3>

			<p>
				Define the component's name. The name must follow the
				<a
					href="https://html.spec.whatwg.org/#valid-custom-element-name"
					target="_blank"
					>custom element naming convention</a
				>.
			</p>

			<pre>
				<p class="code-label">javascript</p>
				<code data-lang="text/javascript">
ardi({
	component: 'gauge-demo',
})
				</code>
			</pre>

			<hr />

			<h3 id="props">props</h3>

			<p>
				Props are defined in array syntax in an object. Each prop's array
				contains a setter function and (optionally) a default value. Setter
				functions can be built-in functions (like
				<code>String</code>, <code>Number</code>, or <code>JSON.parse</code>),
				arrow functions, or another function in your component. Every prop is
				reactive and accessible from <code>this</code>.
			</p>

			<pre>
				<p class="code-label">javascript</p>
				<code data-lang="text/javascript">
ardi({
	props: {
		// setter function
		label: [String],
		// setter function and defaults
		max: [Number, 120],
		min: [Number, 0],
		step: [Number, 10],
		value: [Number, 90],
	},
})
				</code>
			</pre>
			<hr />

			<h3 id="state">state</h3>

			<p>
				State can be declared as an object or as a function that returns an
				object. Each state value is reactive and accessible from
				<code>this.state</code>.
			</p>

			<pre>
				<p class="code-label">javascript</p>
				<code data-lang="text/javascript">
ardi({
	state() {
		return { dialRotation: this.min }
	},

	intersect(ratio) {
		if (ratio > 0.3) {
			this.state.dialRotation = this.deg(this.value / this.max)
		}
	},
})
				</code>
			</pre>

			<hr />

			<h3 id="template">template()</h3>

			<p>
				Use the template function to return a tagged template literal. For
				ultra-fast template updates, Ardi uses the
				<a href="https://www.npmjs.com/package/uhtml" target="_blank">μhtml</a>
				library, which is a subset of
				<a
					href="https://github.com/WebReflection/lighterhtml#readmeackage/uhtml"
					target="_blank"
					>lighterhtml</a
				>.
			</p>

			<h4 id="slots">slots</h4>
			<p>
				If you enabled
				<a
					href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM"
					rel="nofollow"
					>Shadow DOM</a
				>, you can use
				<a
					href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement"
					rel="nofollow"
					>&lt;slot&gt; tags</a
				>
				inside your template. You can use the default slot or multiple named
				slots.
			</p>

			<h4 id="parts">parts</h4>
			<p>
				<a
					href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/part"
					rel="nofollow"
					>Part attributes</a
				>
				allow you to expose an element from the Shadow DOM to be styled by
				external CSS rules using the <code>::part()</code> pseudo-selector.
			</p>

			<h4 id="refs">refs</h4>
			<p>
				Any element with a <code>ref</code> attribute will be added to
				<code>this.refs</code>, i.e. <code>this.refs.dial</code> in the example
				below.
			</p>

			<h4 id="events">events</h4>
			<p>
				You can add Vue-style <code>@event</code> attributes anywhere in your
				markup. Note that raw expressions will cause a rendering loop, similar
				to React, so it is best to use an inline arrow function, i.e.:
				<br />
				<code>@click=${() => this.count += this.step}</code>
			</p>

			<pre>
				<p class="code-label">javascript</p>
				<code data-lang="text/javascript">
ardi({
	template() {
		return html`${this.numbers().map(
				(num) => html`
					&lt;div
						part="number"
						style=${`transform: rotate(${num.deg}deg)`}
					&gt;
						&lt;i style=${`transform: rotate(${-num.deg}deg)`}&gt;${num.label}&lt;/i&gt;
					&lt;/div&gt;
				`
			)}
			&lt;div part="dial"&gt;&lt;/div&gt;
			&lt;slot name="label" part="label"&gt;${this.label}&lt;/slot&gt;

			&lt;style&gt;
				:host {
					align-items: center;
					background: var(--background, #000);
					border: 2px solid rgba(125, 125, 125, 0.5);
				/* etc etc etc */
			&lt;/style&gt;`
	},
})
				</code>
			</pre>

			<hr />

			<h3 id="ready">ready()</h3>
			<p>
				The <code>ready</code> function runs once when the component is loaded.
				This is a good place to apply effects, setup observers, etc.
			</p>

			<pre>
				<p class="code-label">javascript</p>
				<code data-lang="text/javascript">
ardi({
	ready() {
		console.log(`${this.component} is loaded`)
	},
})
				</code>
			</pre>

			<hr />
			<h3 id="intersect">intersect(ratio)</h3>
			<p>
				Use the <code>intersect</code> function to apply effects when the
				component is scrolled into view. This is a very useful way to trigger
				scroll-based animations or lazy-load content. You may use the
				<code>ratio</code> parameter to determine how much of the component
				should be visible before you run your effects. Ardi is optimized so that
				the intersection observer is only created if you use this key, so
				exclude it if you do not intend to use it.
			</p>

			<pre>
				<p class="code-label">javascript</p>
				<code data-lang="text/javascript">
ardi({
	intersect(ratio) {
		if (ratio > 0.3) {
			const val = this.deg(this.value / this.max)
			this.refs.dial.style.transform = `rotate(${val}deg)`
		}
	},
})
				</code>
			</pre>

			<br /><br /><br />

			<h2 id="advanced">Advanced</h2>

			<p>
				Ardi allows you to customize the DX based on your needs and preferences.
			</p>

			<hr />

			<h3 id="render">render()</h3>

			<p>
				The <code>render</code> runs once when a component is loaded and again
				every time a prop's state changes. The default templating library,
				<a href="https://www.npmjs.com/package/uhtml" target="_blank">μhtml</a>,
				is <i>extremely</i> efficient, updating just the parts of the template
				that have changed (much like lit). This allows Ardi components to work
				very smoothly with other frameworks like React and Vue.
			</p>
			<h4>Bring Your Own Templating Library</h4>
			<p>
				If you prefer to use a different templating system, you can do so by
				overriding the default render function with your own. Here are two
				examples using
				<a href="https://handlebarsjs.com/" target="_blank">handlebars</a> and
				<a href="https://www.npmjs.com/package/jsx-dom" target="_blank"
					>jsx-dom</a
				>.
			</p>

			<p>
				<a href="/playground.html?component=helloHbs">
					&lt;hello-world&gt; written in Handlebars
				</a>
			</p>
			<p>
				<a href="/playground.html?component=helloJsx">
					&lt;hello-world&gt; written in JSX
				</a>
			</p>

			<br /><br /><br />

			<h2 id="frameworks">Ardi + Other Frameworks</h2>

			<p>
				Ardi plays well with others! Like lit, μhtml only updates the parts of
				the template that have changed, allowing Ardi components to react
				<i>extremely</i> quickly to interactions with components from other
				frameworks. The pens embedded below show how Ardi's reactivity interacts
				with React and Vue. If you pay careful attention to the
				<code>&lt;hello-world&gt;</code> component in the DevTools as you
				interact with the React and Vue components, you can see how efficient
				Ardi's rendering system is, which is the secret sauce that allows it to
				work so well with other frameworks.
			</p>

			<hr />

			<h3>Ardi ❤️ React</h3>
			<iframe
				allowfullscreen="true"
				allowtransparency="true"
				frameborder="no"
				height="500"
				loading="lazy"
				scrolling="no"
				src="https://codepen.io/jameslovallo/embed/XWqNNNo?default-tab=js%2Cresult&editable=true&theme-id=dark"
				style="width: 100%"
				title="Ardi ❤️ React"
			></iframe>

			<hr />

			<h3>Ardi ❤️ Vue</h3>
			<iframe
				allowfullscreen="true"
				allowtransparency="true"
				frameborder="no"
				height="500"
				loading="lazy"
				scrolling="no"
				src="https://codepen.io/jameslovallo/embed/KKRgrrd?default-tab=js%2Cresult&editable=true&theme-id=dark"
				style="width: 100%"
				title="Ardi ❤️ Vue"
			></iframe>
		</div>
	</main>

	<script type="module">
		import loader from 'https://cdn.skypack.dev/@monaco-editor/loader@1.3.2'
		loader.init().then((monaco) => {
			document.querySelectorAll('code').forEach((c) => {
				monaco.editor.colorizeElement(c, {
					fontSize: '13px',
					tabSize: 2,
					theme: 'vs-dark',
				})
			})
		})
	</script>
</body>
